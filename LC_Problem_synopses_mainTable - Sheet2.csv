leetcode_num,diff_level,category_1,category_2,approach_name,problem_name,problem_solution
704,Easy,Array,,Binary Search,Binary Search,"Min be start index of array, max be end index. While min is less than or equal to max: (re)calculate middle by taking average of min and max. if middle value (not index) is target, return middle index. If middle value is less than target search right half + 1, else search left half - 1"
944,Easy,Matrix,,,Delete Columns,"Init variable to store number of coumns to be deleted. Then do a colum traversal on matrix: for colum in range of length of first string, for row in range of length of total number of strings starting at second row, if letter in row above is less than curr row increment delete_col variable. BREAK out of loop to prevent multiple counts of out of order in one colum "
412,Easy,Array,,,Fizz Buzz,"One indexed so make sure range is (1, n + 1). Make sure to mod 3 and 5 together "
2418,Easy,Hash Map,Sort,,Sort the People,"Use a hashmap to store the height and the index. Sort keys of the hashmap, iterate over the sorted keys to append the names in order of the sorted height."
495,Easy,Array,Intervals,,Teemo Attacks ,Create an array of intervals. Merge Intervas. Count duration
520,Easy,String,,,Detect Capitals ,"Three booleans or ifs: if equal to word.upper, if equal to word.lower, or if equal to word.capitalize. Or you can be more manual and check if first letter is capital, then a slice of the rest of the word is lower, ie [1:] "
409,Easy,Hash Map,,Frequency Counter,Longest Palindrome,"Make frequency counter. Iterate over it: if a frequency is even, add it to total length. Else, add the odd frequency numbers, but minus 1 to get more even numbers. After loop, add 1 to length for the presence of any odd frequencies, b/c they can be used as the middle letter."
572,Easy,Binary Tree,,,Sub Tree of another Tree,Combine Same Tree with another function that runs Same Tree on each node
1974,Easy,Array,,,Get Minimum Time to Type ,The trick is to calculate both directions and get the min. Make sure to use abs() 
3083,Easy,String,,,Existence of 2 char Substr in Reversed,"iterate through reversed string using a sliding window slice, comparing against input string. Return true if any size two window slice is there, else false "
2678,Easy,String,Array,,Count Seniors ,"iterate through details strings, checking if the proper portion of the array converted to int is greater than sixy and keepig a count."
88,Easy,Array,,,Merge Sorted Array,"Two pointers, one at where the numbers end in nums1:  m - 1 , other at the end of nums2: n - 1. A third pointer nums1end that starts from very end of nums1:  m + n -1.   while p1 >= 0 and p2 >= 0: if p2 > p1, copy p2 to nums1end, decrement p2...Else copy p1 to nums1end and decrement p1. Always decrement nums1end.    while p2 >= 0 copy p2 to nums1end and decrement p2 and decrement nums1end."
27,Easy,Array,,,Remove Element,"initi left pointer to 0. start for loop with right pointer at 0: if right is the value, skip it and loop to next element ( 'continue' loop), if it's different than value, copy right to left. return left. "
26,Easy,Array,,,Remove Duplicates Sorted Array,"Use two pointers k and i. k is for unique elements and i goes out ahead of k for the duplicates. i and k start at 1. while i less than length of array, if nums of i_dups is not equal to nums of one before nums of k_unique, duplicate run has ended so copy i over to k and increment k_unique, else keep incrementing i_dups. "
80,Medium,Array,,,Remove Duplicates Sorted Array 2,Similar to above except i and k start at 2. Also in the while loop: if nums[i] not equal to nums[k-2] copy i over to k. increment k.    keep incrementing i. 
169,Easy,Array,,Boyer-Moore,Majority Element,"Boyer-Moore voting algo:. initialize variable candidate to None, and count to zero. Iterate through elements, if the count is zero, assign curr element to candidate. Then if else: if the element is same as candidate, increment count, else decrement count. Return candidate"
189,Medium,Array,,,Rotate Array,"definte reverse function that takes in a start and end. Next redefine k as modulo to the length of nums array in case k larger than nums length. Then three reversals: enitre array, first k elements, then rest of array. ."
121,Easy,Array,,,Best Time to Buy and Sell Stock,"initialize min price to the first item in array and init max profit to be 0. Loop through array: the minimum price is the lowest number we've seen or the current one in loop(minPrice starts at [0]. Max profit is the larger of current - min, or the the last max profit we've seen "
122,Medium,Array,,,Best Time to Buy and Sell Stock II,"init max profit to 0. Stragegy: loop from one in on array, you're looking for any situation where the next number is bigger than the number before, and if thats so you can just total up the difference from current number with number before and that in aggregate will get you all the profit you can make if you can buy and sell multiple times"
55,Medium,Array,,,Jump Game,"init furthest to 0. for i in range len nums, first check if current i is greater than furthest, you're stuck so return false. Calculate furthest as the max of current furthest or the value of current index plus the index itself. If furthest is greater than or equal to THE LAST INDEX  return true "
45,Medium,Array,,,Jump Game II,"Similar to jump game except extra variable to count jumps, and a variable to store current_range_end. In loop, calculate furthest same as Jump game, then check if i has reached current_range_end, if so incr jumps and assign the next calculated furthest to current_range end. Then check if current_range_end has reached the last index, then break loop and return jumps"
238,Medium,Array,,,Product of Array except Self,"Create result array that is the length of nums filled with 1's. variable left prod set to 1, loop through nums: storre left product in each i of result, multiply left prodcut by nums[i]. Var right product set to 1, reverse loop nums and mulitply result[i] with right product and get next right product by multiplying against nums[i["
134,Medium,Array,,,Gas Station ,"init total_gas, current_gas, startstation to 0. In loop over gas arr: calculate totalgas and current gas with same formula: gas[i] - cost[i] AS A RUNNING SUM. If curr gas is < 0  assing startstation to one after i and reset current gas to 0. return startstaton if total gas is > 0 or else -1"
13,Easy,Array,,,Roman to Integer,it was here til i fuckin deleted it by acciedent.
12,Medium,Array,String,,Integer to Roman,"Store array of tuples in descending order:  (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'),  (1, 'I'). Make empty result variable string. Iterate over value, rn, in array: while (from input) num in its current state is greater or equal to current value in tuple array, append the corresponding roman numeral to result, subtract that value from num . Return roman numeral"
58,Easy,Array,String,,Length of Last Word , PYTHON: return length of strring dot strip dot split of last index 
14,Easy,Array,String,,Longest Common Prefix,"Make the enitre first string the prefix. loop through all the other strings in array: inner loop: while current word not startswith prefix, chop the initial prefix down by one character at end : prefix = prefix.substring(0, prefix.length - 1), in python use [:-1].  if prefix is empty then return empty string.  return the longest common prefix "
151,Medium,Array,String,,Reverse Words In String ,split input string s in to s array. Two pointer left right swap on the array. return s array joined back into string with a space
28,Easy,Array,String,,Find Index of First Occurence (strStr),"If check for not needle or needle being longer than haystack. Outer for loop iterates with an i counter over range len(haystack)  - len(needle) + 1. In loop initialize ptr j to 0 for needle. Inner while loop, while j is less than needle lenght AND haystack[offset i plus j] matchrs needle[j], incr j. In for loop if j is needle length return i. Outside for loop return -1"
380,Medium,Array,,,Insert Delete Get Random 0(1),"init: a hashmap and an array. Also make a swap method for convenience that takes an array, and start and end. INSERT: check if value is in hashmap, if not, add it to end of array, the add to hashmap with val as key and index of end of array as value. Ret True, else return false. DELETE: get the value to remove's index, get value of last entry in array, swap the value with the last value in array, update index of last element that got swapped, remove from array and hashmap. RANDOM: just call random.choice on array"
53,Medium,Array,Kadane,,Maximum Subarray,"Two vars: max_current and max_global set to float('-inf'). Loop through aray: calculate local subarray max by taking the max of max_current  + nums[i], which is the running total, or nums[i] (restart). Then get global max by taking max of max_current or max global. Return max global.  Two levels of greedy going on "
125,Easy,String,,Two Pointers,Is palindrome ,"(python) s = """".join(char.lower() for char in s if char.isalnum()); to remove spaces and only alphanumeric chars. Then two pointers that start at beginning and end. While loop as along as lp > rp if at any point lp isnt the same as right return false. Increment lp and decrement rp.... make it outside loop, return true. )"
392,Easy,String,,Two Pointers,Is Subsequence,"Both pointers begin at beginning of short string and long string. Check if short is empty (true), otherwise wont pass. While you havent reached the end of the long string: if  shortptr and longptr match, increment shortptr. _no matter what_ increment longptr. if you get to the end of the short string in the loop, return true. Otherwise (outside of loop) return false"
167,Medium,Array,,Two Pointers,Two Sum II,"left pointer at 0, right pointer at end of array. Whle left pointer is less than right poitner: init sum as numbers of left and right poitners added together. if sum is target, return array of left pointer + 1 and right poiinter + 1, else if sum is greater than target decrement right pointer, else decrement left pointer. "
3,Medium,String,,Sliding Window,Longest Substring Without Repeating Characters,"Two pointers left and right. Intil. a set and call it unique. init max_len and set to 0.  While right pointer is less than len(string): if the letter at right ptr is not in unique set, add it, incr right ptr, then calculate max_len as either max len itself or the length of the unique set. ELSE remove char at left pointer from the unique set and increment left pointer. outside while return max_len"
209,Medium,Array,,Sliding Window,Minimum size subarrray sum ,"Init lptr 0, rptr 0, min_size to float('inf') and sum 0. Outer while while rptr less than nums length, running sum and incr right ptr. Inner while while sum is >= target: calculate min length subtract number from lptr, incr left pointer. Ouside outer while, if min lenght is still infinity return zero else return minlength "
383,Easy,String,Hash Map,Frequency Counter,Ransom Note,"Two frequency counters, one for ransom note and one for magazie. Then logic: // magazine must have the letters of the ransom note: if( !(key in magazineMap) ) return false.   // Each letter in magazine can only be used once in ransomNote:   if( ransomNoteMap[key] > magazineMap[key] ) return false"
290,Easy,String,Hash Map,,Word Pattern ,"Split words into word array.If pattern and words arent same length return false. Initialize object/map. For i in range: First check for pattern character in hash map: if its there and if the corresponding letter is not same as current word, return false, elset if the current word is in the hashmap's values it's associated with another letter so return false.  Then build hashmap with key as pattern charater and value as the current word"
242,Easy,String,Hash Map,,Valid Anagram,Check if the strings are same length. Then two frequency counters: one for each string. // checks for all same characters: if not key in otherMap  return false. // checks for same frequency if( tCount[key] !== sCount[key] ) return false; 
1,Easy,Array,Hash Map,,Two Sum,"Initialize map. In loop (for i, nums in enumerate(nums)) calculate complement: let complement = target - currentNum, then check the hashMap for it:  if( complement in map ) { return [ map[complement], i ] } so you retrun the indicies of the number and compelent that add to target. then add to hashmap:  map[currentNum] = i"
219,Easy,Array,Hash Map,,Contains Duplicate 2 ,"Similar to Two Sum. Loop: (use i, current_num enumerate in python). If current_num in hashmap theres a dup so assign j to index of current_num by checking the hashmap, and check that it is also k indicies away: if Math.abs( (i - j <= k ) ) return true. Build hashmap of num as key and index as value. Otherwise, of course return false "
202,Easy,Math,Hash Map,,Happy Number,"Init hashmap. loop: while( n != 1 ) check for n itself in hashmap, if so theres a cycle so return false. Otherwise add n to map and a dummy value. Then calculate next value of n with generator that squares and adds digits: n = sum(int(digit) ** 2 for digit in str(n)) "
205,Easy,String,Hash Map,,Isomorphic Strings,"FIrst check if strings are of different length. Initialize two hashmaps. Loop iterate over s with an index i to also iterate over t: if if an s char isnt in s_map, put it in and assign its value to t char, else if that s char is in the s map and its mapped to a different character (!==), return false. *Do the same for t to s!! Leave loop without a false, return true, strings are isomorphic "
49,Medium,String,Hash Map,,Group Anagrams,"init a hashmap. For word in strs: sort word with """".join(sorted(s)), if sorted word not in hashmap, put it there with an empty array as value. Otherwise every time look up sorted str and append its raw unsorted version from strs array. Outside loop return a list of the hashmap.values"
228,Easy,Array,Intervals,,Summary Ranges ,"Initialize pointer i to mark start of next range, j to traverse range, and an array to store ranges. Outer loop is while loop j ptr is not end of nums: Inner while: does a consecutive range: while one after j index hasnt reached end AND one after j is a consecutive number (+1), increment j.  back to outer while:  If i == j push in nums[i] only, else push in i->j. then incr j by 1 to start new range and i = j to mark new range"
56,Medium,Array,Intervals,,Merge Intervals,"Sort intervals. Add first interval to result array. Iterate starting from second interval in intervals. Compare the ending time of the last interval in result to the start time of the current interval in loop. if they overlap, the end time of the last interval in result array becomes the max of its end time or the end time of the current interval in loop. Otherwise, just add then next interval."
150,Medium,Stack,,,Evaluate Reverse Polish Notation ,"Create an array with operators in it.Create an empty stack.Make a helper function that perfomrs operations, make sure div is int(op1 // op2). Iterate through the tokens, if the token isnt an operator, convert to int add operand to stack. else youve hit an operator so pop the last two operands off stack, perform operation, then push result back to stack. Outside of loop pop final value off of stack and return it"
20,Easy,Stack,,,Valid Parentheses,"Create empty stack and a Map with all open and closed brackets. Loop: init var for top of stack, check if stack is empty. If the current character is an opening bracket (check key in dict), push it to stack. else, the current character is a closing bracket, so check if the stack is empty and if it matches the most recent opening bracket on the stack, if it does, pop it. Else return false. Last return, return true if stack is empty"
141,Easy,Linked List,,,Linked Cycle ," if (!head || !head.next) return false, ie no cycle if there are 0 or 1 nodes. Initialize fast and slow pointers to head.While fast && fast.next are true, move slow to next and fast to next next. If slow ends up == fast there's a cycle, else false no cycle "
21,Easy,Linked List,,,Merge Two Sorted Lists,"Init dummy node to -1 ( new ListnNode). Init two pointers p1 and p2 to point to list1 and list2. Init current var to dummy  While both p1 and p2 are not None: if p1.val <= to p2.val, add the node from list1(p1) to merged list (link to next), move p1 to its next node. else add node from list 2 and move p2 pointer. move curr to next then append any leftovers from either list"
206,Easy,Linked List,,,Reverse Linked List,"init two variables: current to head and prev to none. while current is not none, store current's next into a variable (eg 'next_node'), point current's next back to prev, move prev to current, then move current to next_node which was storing the rest of the list. ouside loop assign prev to to head and return head "
146,Medium,Linked List,,,LRU Cache,"constructor has an cache as an Ordered Dict and a var to hold capacity. GET: if key in cache: move_to_back the key to make most recent in cache then return value, else return -1. PUT: if key in chache: assign key value to cache and move_to_back, else: evict cache by popitem(last=false), assign key value to cache "
83,Easy,Linked List,,,Remove duplicates from sorted list,"curr is head, while curr and curr next: if curr val is same as curr next val, remove node, otherwise keep iterating "
104,Easy,Binary Tree,,,Max Depth,"if root is none return zero. have variable l_depth assigned to calling the function itself recursively and adding one, do same for r_depth. take the max of both variables and return that."
100,Easy,Binary Tree,,,Same Tree,"Base Case 1: if both trees are null, they are the same. BC2:  If if one tree is null OR the other tree is null, they are different. BC3: If the val of node in p is different than the val of the node in q, then return false. return recursively calls function on p and q's left AND right side: isSameTree(a.left, b.left) AND isSameTree(a.right, b.right)"
226,Easy,Binary Tree,,,Invert Binary Tree,"if root == null return null. This is the base case. Simply swap left and right nodes with a temp variable: temp = root. left, root.left = root.right, then assign right to temp. then call the funciton on itself for the left and right side. Return root."
101,Easy,Binary Tree,,,Symmetric Binary Tree,"Recursive function called isMirror takes in a left and right node: Base case 1: if left is null and right is null return true. Base case 2: if left is null OR right is null return false. Base Case 3: if left val is not equal to right val return false. return isMirror(left.left, right.right) && isMirror( left.right, right.left ). Outside func: return isMirror( root.left, root.right)"
112,Easy,Binary Tree,,,Path Sum,Base Case if root is null return false. Subtract the value of each node from targetSum input with each recursive call. If root left is none and root right is none and the target has decremented to zero there is a path and return true. RETURN  runs the func recursively on the left side with target OR the right side with target bc could be either side. 
222,Easy,Binary Tree,,,Count Nodes,"init count var. traverse inner func that does POSTORDER DFS: nonlocal count,  if not node return 0, if node left traverse node left, if node right traverse node right, increment counter. Call traverse func on root, traverse func return count "
637,Easy,Binary Tree,BFS,,Average of Levels,"Init. queue array and pass in the root/tree. Init. a return array of averages. BFS while queue > 0: initl. level size as queue length, and init level sum to zero. loop thru level size: dequeue, add value to total, push left and right into queue if exist. Outside for loop divide by level size for avg and push into array. Outside while return array of averages "
515,Medium,Binary Tree,BFS,,Largest Value in Each Row,"Very similar to Average of Levels above. Instead, in the BFS while loop we initialize a largest_val variagle to float -inf, in the for loop traverval of the queue/level we do a max calc of curr.val and largest_val, then back in the while loop we append to an array to return the largest values in each row "
530,Easy,Binary Tree,BST,,Minimum Abs Difference in BST,"Initialize minDiff var to float('inf'), and initialize prevVal to undefined/none. InOrder traverse function: in python mark outer vars as nonlocal. if node left traverse node left. if preVal is not undefined: minDiff is the minium of either minDiff or abs(node.val - prev.val)  outside if assign prev.val to node.val.  if node right traverse right.   call the traverse func on the root, return minDiff. "
200,Medium,Graph,,,Number of islands ,
108,Easy,Array,BST,Divide and Conquer,Sorted Arrray to BST,"if empty array return null. init middle variable to the current length of array / 2 rounded, always the half way point. * init a root node to a new TreeNode(nums[middle]) *. recur call root.left to = the function slicing the array from 0 to middle. recur call root.right to = the func slicing the array from middle + 1 to end.  return root. "
35,Easy,Array,,Binary Search,Search Insert Position ,"Straight binary search, but you just return the min variable if the target isn't found in the main loop. "
67,Easy,Bit Manipulation,,,Add Binary (add two binary strs),"Max func get lenght of longest str, helper function takes str and length to pad zeros, pad both strings shorter gets padded. Initl. carry to 0 and result to empty string. For loop through both bstrings in reverse maxStrLength, parse to base 2 each bit in each string, current = bit1 + bit2 + carry, result concatenates current sum mod 2 plus eariler result, carry calculated by current sum // 2. if carry after loop add ""1"" to result"
190,Easy,Bit Manipulation,,,Reverse Bits,Init result variable to 0. For loop that iterates 32 times: read from the input LSB by ANDing with 1 then bit shift to next place: let bit = (n >>> i) & 1. Then write the bit in reverse starting at result's MSB using OR: result = result | (bit << (31 - i) ). return result >>> 0 // Ensure the result is treated as an unsigned integer with >>>
191,Easy,Bit Manipulation,,,Hamming Weight,"Initialize result variable to zero. Initialize bitMask to 1.  For loop from zero to < 32: if the input ANDed with bitMask is not 0 (ie, 1), increment result variable. Bit shift the mask by 1 to the left: bitMask = bitMask << 1. Ouside loop return result. "
136,Easy,Bit Manipulation,,,Single Number,"return nums.reduce( (result, val) => result ^ val ). That's it.  XOR of a number with itself results in 0, and XOR of a number with 0 results in the number iself. So all the duplicates are cancelled out and you're left with the single number. "
9,Easy,Math,,,Is Palindrome (number),If the number is negreturn false. If the number is 1 - 9 return true. Initl. a reversedNum var to 0. Initl. a temp variable to the input number. while temp > 0 :  calculate digit by mod the temp by 10' add digit to reverseNum by multiplying reverseNum by 10 to make space then adding digit. remove number from temp by dividing temp by 10 and rounding. Return true if input === reversenum.
66,Easy,Math,,,Plus One,"Initl. carry var to 1, since that's what we're adding. for loop reverse from end of array: sum = current digit plus carry. Then calculate carry by floor division of sum by 10. Then update current digit by moduloing the sum by 10. Outside loop, any leftoer carry digit get unshifted to beginning of array. return array "
70,Easy,Dynamic Programming,,,Climbing Stairs,"Approach: recursion with memoization by way of dictionary. Add memo={} to func arguments.  In function: Base case if n is 1 return 1, base case if n is 2 return 2. Then check if n is in memo dict and return that if it is. Otherwise, store in memo[n] the recursive call of n - 1 + n -1, making sure to pass memo into the call to keep the dict going for the recursion "